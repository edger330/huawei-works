/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>
#include <assert.h>
#include <ctype.h>
#include <limits>
#include <sys/time.h>
#include <algorithm>
#include <immintrin.h>
#include <emmintrin.h>
#include <omp.h>

#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <fenv.h>
#include "utils.h"
/* Header for class org_broadinstitute_gatk_utils_smithwaterman_BatchSWPairwiseAlignment */

#include "org_broadinstitute_gatk_utils_smithwaterman_BatchSWPairwiseAlignment.h"
using namespace std;
/*
 * Class:     org_broadinstitute_gatk_utils_smithwaterman_BatchSWPairwiseAlignment
 * Method:    jniInit
 * Signature: (Lorg/broadinstitute/gatk/utils/smithwaterman/BatchSWPairwiseAlignment/OVERHANG_STRATEGY;Lorg/broadinstitute/gatk/utils/smithwaterman/Parameters;Z)V
 */
 const char * strategyName=NULL;
 bool cutOff = false;

//jmethodID arraylist_size;
/*jclass cls_arraylist;
jmethodID arraylist_construct;
jmethodID arraylist_add;
jmethodID arraylist_set;
jclass CigarElement;
jmethodID CigarElement_construct;
jclass Cigar;
jmethodID Cigar_construct;
jclass CigarOperator;
jmethodID CigarOperator_construct;*/

Parameter para;

JNIEXPORT void JNICALL Java_org_broadinstitute_gatk_utils_smithwaterman_BatchSWPairwiseAlignment_jniInit
  (JNIEnv * env, jobject obj,jobject strategy, jobject parameter, jboolean cutoff){
// common method initialize
/*    cls_arraylist = env->FindClass("java/util/ArrayList");
    assert(cls_arraylist && "Could not get FID for cls_arraylist");
    arraylist_construct = env->GetMethodID(cls_arraylist,"<init>","()V");
    assert(arraylist_construct && "Could not get FID for arraylist_construct");
    arraylist_add = env->GetMethodID(cls_arraylist,"add","(Ljava/lang/Object;)Z");
    assert(arraylist_add && "Could not get FID for arraylist_add");
    arraylist_set = env->GetMethodID(cls_arraylist,"set","(ILjava/lang/Object;)Ljava/lang/Object;");
    assert(arraylist_set && "Could not get FID for arraylist_set");*/

/*    Cigar = env->GetObjectClass(cigar);
    assert(Cigar && "Could not get FID for Cigar");
    Cigar_construct = env->GetMethodID(Cigar,"<init>","(java/util/ArrayList;)V");
    assert(Cigar_construct && "Could not get FID for Cigar_construct");

    CigarElement = env->GetObjectClass(cigarelement);
    assert(CigarElement && "Could not get FID for CigarElement");
    CigarElement_construct = env->GetMethodID(CigarElement,"<init>","(ILjava/lang/Object;)V");
    assert(CigarElement_construct && "Could not get FID for CigarElement_construct");

    CigarOperator = env->GetObjectClass(op);
    assert(CigarOperator && "Could not get FID for CigarOperator");*/


// get strategy name
    jclass enumStrategy = env->GetObjectClass(strategy);
    jmethodID getVal = env->GetMethodID(enumStrategy, "name", "()Ljava/lang/String;");
    jstring value = (jstring)env->CallObjectMethod(strategy ,getVal);
    strategyName = env->GetStringUTFChars(value, 0);
// get parameters
    jfieldID fid;
    jclass cls = env->GetObjectClass(parameter);
    fid = env->GetFieldID(cls, "w_open", "I");
    para.w_open = (jint)env->GetIntField(parameter, fid);
    fid = env->GetFieldID(cls, "w_extend", "I");
    para.w_extend = (jint)env->GetIntField(parameter, fid);
    fid = env->GetFieldID(cls, "w_match", "I");
    para.w_match = (jint)env->GetIntField(parameter, fid);
    fid = env->GetFieldID(cls, "w_mismatch", "I");
    para.w_mismatch = (jint)env->GetIntField(parameter, fid);

// set cutoff
	cutOff = cutoff;
  }

/*inline jobject makeCigarElement(JNIEnv * env, jobject obj,int length,State state){
    jfieldID op = NULL;
    switch (state) {
        case MATCH:
            {
               op = env->GetStaticFieldID(CigarOperator,"M","LSerialPort$Parity;");
            }
            break;
        case INSERTION:
            {
                op = env->GetStaticFieldID(CigarOperator,"I","LSerialPort$Parity;");
            }
            break;
        case DELETION:
            {
                op = env->GetStaticFieldID(CigarOperator,"D","LSerialPort$Parity;");
            }
            break;
        case CLIP:
            {
                op = env->GetStaticFieldID(CigarOperator,"S","LSerialPort$Parity;");
            }
            break;
    }
    return env->NewObject(CigarElement,CigarElement_construct,length,op);
}*/
inline void compute_matrix( JNIEnv *env, jobject obj, char * reference, char * alternate,
                            int** sw, int ** btrack, int nrow, int ncol){
	int MATRIX_MIN_CUTOFF;   // never let matrix elements drop below this cutoff
    if ( cutOff ) MATRIX_MIN_CUTOFF = 0;
    else MATRIX_MIN_CUTOFF = (int) -1e8;
    int minIntValue = std::numeric_limits<int>::min()>>1;

    int* best_gap_v = new int[ncol+1];
    std::fill_n(best_gap_v,ncol+1,minIntValue);
    int* gap_size_v = new int[ncol+1];
    int* best_gap_h = new int[nrow+1];
    std::fill_n(best_gap_h,nrow+1,minIntValue);
    int* gap_size_h = new int[nrow+1];

    if(strcmp(strategyName, "INDEL")==0 || strcmp(strategyName, "LEADING_INDEL")==0){
        // initialize the first row
        sw[0][0]=0;
        int* topRow=sw[0];
        topRow[1]=para.w_open;
        int currentValue = para.w_open;
        for ( int i = 2; i < ncol; i++ ) {
            currentValue += para.w_extend;
            topRow[i]=currentValue;
        }
        // initialize the first column
        sw[1][0]=para.w_open;
        currentValue = para.w_open;
        for ( int i = 2; i < nrow; i++ ) {
            currentValue += para.w_extend;
            sw[i][0]=currentValue;
        }
    }
    int* curRow=sw[0];
    jboolean is_copy=JNI_FALSE;
/*    unsigned char * ref = new unsigned char[nrow-1];
    unsigned char * alt = new unsigned char[ncol-1];
    env->GetByteArrayRegion (reference, 0, nrow-1, reinterpret_cast<jbyte*>(ref));
    env->GetByteArrayRegion (alternate, 0, ncol-1, reinterpret_cast<jbyte*>(alt));*/
/*    jbyte* ref = env->GetByteArrayElements(reference, &is_copy);
    jbyte* alt = env->GetByteArrayElements(alternate, &is_copy);*/
    for ( int i = 1; i <nrow ; i++ ) {
        char a_base = reference[i-1]; // letter in a at the current pos
        int* lastRow=curRow;
        curRow=sw[i];
        int* curBackTrackRow=btrack[i];
        for ( int j = 1; j < ncol; j++) {
            char b_base = alternate[j-1]; // letter in b at the current pos
            // in other words, step_diag = sw[i-1][j-1] + wd(a_base,b_base);
            int step_diag = lastRow[j-1] + (a_base == b_base ? para.w_match : para.w_mismatch);

            // if a gap (length 1) was just opened above, this is the cost of arriving to the current cell:
            int prev_gap = lastRow[j]+para.w_open;
            best_gap_v[j] += para.w_extend; // for the gaps that were already opened earlier, extending them by 1 costs w_extend
             if (  prev_gap > best_gap_v[j]  ) {
                best_gap_v[j] = prev_gap;
                gap_size_v[j] = 1; // remember that the best step-down gap from above has length 1 (we just opened it)
            } else {
                // previous best gap is still the best, even after extension by another base, so we just record that extension:
                gap_size_v[j]++;
            }
            int step_down = best_gap_v[j] ;
            int kd = gap_size_v[j];

            prev_gap =curRow[j-1]  + para.w_open; // what would it cost us to open length 1 gap just to the left from current cell
            best_gap_h[i] += para.w_extend; // previous best gap would cost us that much if extended by another base
            if ( prev_gap > best_gap_h[i] ) {
                // newly opened gap is better (score-wise) than any previous gap with the same row index i; since
                // gap penalty is linear with k, this new gap location is going to remain better than any previous ones
                best_gap_h[i] = prev_gap;
                gap_size_h[i] = 1;
            } else {
                gap_size_h[i]++;
            }
            int step_right = best_gap_h[i];
            int ki = gap_size_h[i];

            //priority here will be step diagonal, step right, step down
            bool diagHighestOrEqual = (step_diag >= step_down)
                                            && (step_diag >= step_right);

            if ( diagHighestOrEqual ) {
                curRow[j]=max(MATRIX_MIN_CUTOFF,step_diag);
                curBackTrackRow[j]=0;
            }
            else if(step_right>=step_down) { //moving right is the highest
                curRow[j]=max(MATRIX_MIN_CUTOFF,step_right);
                curBackTrackRow[j]=-ki; // negative = horizontal
            }
            else  {
                curRow[j]=max(MATRIX_MIN_CUTOFF,step_down);
                curBackTrackRow[j]= kd; // positive=vertical
            }
        }
    }
/*    env->ReleaseByteArrayElements(reference,ref,0);
    env->ReleaseByteArrayElements(alternate,alt,0);*/
/*
    delete[] ref;
    delete[] alt;*/
    delete[] best_gap_v;
    delete[] gap_size_v;
    delete[] best_gap_h;
    delete[] gap_size_h;

}

inline void compute_cigar(JNIEnv *env, jobject obj, int refLen , int altLen,int ** sw, int ** btrack,
					string& s){



	int p1=0, p2=0;
	int maxscore = std::numeric_limits<int>::min();
	int segment_length=0;
	if(strcmp(strategyName, "INDEL")==0){
		p1 = refLen;
		p2 = altLen;
	}
	else{
		p2 = altLen;
		for(int i=1;i<refLen+1; i++){
			int curScore = sw[i][altLen];
			if(curScore >= maxscore){
				p1 = i;
				maxscore = curScore;
			}
		}
		if(strcmp(strategyName, "LEADING_INDEL")!=0){
			int * bottomRow = sw[refLen];
			for(int j=1; j<altLen+1; j++){
                int curScore=bottomRow[j];
                // data_offset is the offset of [n][j]
                if ( curScore > maxscore ||
                        (curScore == maxscore && abs(refLen-j) < abs(p1 - p2) ) ) {
                    p1 = refLen;
                    p2 = j ;
                    maxscore = curScore;
                    segment_length = altLen - j ; // end of sequence 2 is overhanging; we will just record it as 'M' segment
                }

			}

		}
	}
    if ( segment_length > 0 && strcmp(strategyName,"SOFTCLIP")==0 ) {
        s+="CLIP";
        s+=":";
        s+=int_to_string(segment_length);
        s+=" ";
/*        jobject ce = makeCigarElement(env,obj,segment_length,CLIP);
        env->CallObjectMethod(list_ce,arraylist_add,ce);*/
        segment_length = 0;
    }
    State state = MATCH;
    do{
        int btr = btrack[p1][p2];
        State new_state;
        int step_length = 1;
        if(btr >0 ){
            new_state = DELETION;
            step_length = btr;
        }
        else if( btr<0){
            new_state = INSERTION;
            step_length = -btr;
        }
        else{
            new_state = MATCH;
        }
        switch(new_state){
            case MATCH:
            {
                p1--;
                p2--;
            }
                break;
            case INSERTION:
                p2 -= step_length;
                break;
            case DELETION:
                p1 -= step_length;
                break;
        }

        if(new_state==state) segment_length += step_length;
        else{
            s+=ToString(state);
            s+=":";
            s+=int_to_string(segment_length);
            s+=" ";
/*            jobject ce = makeCigarElement(env,obj,segment_length,state);
            env->CallObjectMethod(list_ce,arraylist_add,ce);*/
            segment_length = step_length;
            state = new_state;
        }
    }while(p1>0 && p2>0);

    if ( strcmp(strategyName,"SOFTCLIP")==0 ) {
        s+=ToString(state);
        s+=":";
        s+=int_to_string(segment_length);
        s+=" ";
/*        jobject ce = makeCigarElement(env,obj,segment_length,state);
        env->CallObjectMethod(list_ce,arraylist_add,ce);*/
        if ( p2 > 0 ){
            s+="CLIP";
            s+=":";
            s+=int_to_string(p2);
            s+=" ";
/*            jobject ce = makeCigarElement(env,obj,p2,CLIP);
            env->CallObjectMethod(list_ce,arraylist_add,ce);*/
        }
//        alignment_offset = p1;
        s+='|';
        s+=int_to_string(p1);
    } else if ( strcmp(strategyName,"IGNORE")==0 ) {
        s+=ToString(state);
        s+=":";
        s+=int_to_string(segment_length+p2);
        s+=" ";
        s+='|';
        s+=int_to_string(p1-p2);
/*        jobject ce = makeCigarElement(env,obj,segment_length+p2,state);
        env->CallObjectMethod(list_ce,arraylist_add,ce);
        alignment_offset = p1 - p2;*/
    } else {  // overhang_strategy == OVERHANG_STRATEGY.INDEL || overhang_strategy == OVERHANG_STRATEGY.LEADING_INDEL

        // take care of the actual alignment
        s+=ToString(state);
        s+=":";
        s+=int_to_string(segment_length);
        s+=" ";
/*        jobject ce = makeCigarElement(env,obj,segment_length,state);
        env->CallObjectMethod(list_ce,arraylist_add,ce);*/
        // take care of overhangs at the beginning of the alignment
        if ( p1 > 0 ){
        s+="DELETION";
        s+=":";
        s+=int_to_string(p1);
        s+=" ";
/*            jobject ce = makeCigarElement(env,obj,p1,DELETION);
            env->CallObjectMethod(list_ce,arraylist_add,ce);*/
        }
        else if ( p2 > 0 ){
        s+="INSERTION";
        s+=":";
        s+=int_to_string(p2);
        s+=" ";
/*            jobject ce = makeCigarElement(env,obj,p2,INSERTION);
            env->CallObjectMethod(list_ce,arraylist_add,ce);*/
        }
        s+='|';
        s+=int_to_string(0);
//        alignment_offset = 0;
    }
}

string join( vector<string>& elements, string delimiter )
  {
    string ss;
    size_t elems = elements.size(),
    last = elems - 1;

    for( size_t i = 0; i < elems; ++i )
    {
        ss+=elements[i];

        if( i != last )
            ss += delimiter;
    }

   return ss;
 }

string compute_testcases(JNIEnv * env, jobject obj,vector<testcase>& tc_array, int numTestCases, unsigned maxNumThreadsToUse)
{
    vector<string> sstr;
    sstr.resize(numTestCases);
//    int numThreads = omp_get_num_procs() * 0.8;
#pragma omp parallel for schedule (dynamic,10) num_threads(maxNumThreadsToUse)
    for(int i =0; i<numTestCases; i++){
        int refLen = tc_array[i].refLen;
        int altLen = tc_array[i].altLen;
        char * reference = tc_array[i].reference;
        char * alternate = tc_array[i].alternate;

        if(refLen==0 || altLen==0){
            cerr<<"NULL reference or alternate";
            exit(1);
        }
        int nrow = refLen+1;
        int ncol = altLen+1;
        int** sw = new int*[nrow];
        int** btrack = new int*[nrow];
        for(int i = 0; i < nrow; ++i){
            sw[i] = new int[ncol];
            btrack[i] = new int[ncol];
            std::fill_n(btrack[i],ncol,0);
            std::fill_n(sw[i],ncol,0);
        }

/*        jobject list_ce = env->NewObject(cls_arraylist,arraylist_construct,"");
        int alignment_offset;*/
        compute_matrix(env, obj, reference, alternate, sw,btrack, nrow, ncol);
        compute_cigar(env, obj, refLen, altLen, sw, btrack, sstr[i]);
/*        jobject cigar = env->NewObject(Cigar,Cigar_construct,list_ce);
        env->CallObjectMethod(cigars, arraylist_add, cigar);
        jclass cls = env->FindClass("java/lang/Integer");
        jmethodID methodID = env->GetMethodID(cls, "<init>", "(I)V");
        jobject align_offset = env->NewObject(cls, methodID, alignment_offset);
        env->CallObjectMethod(alignment_offsets,arraylist_add,align_offset);*/

        for(int j = 0; j < nrow; ++j) {
            delete [] sw[j];
            delete [] btrack[j];
        }
        delete[] sw;
        delete[] btrack;
    }
    string s=join(sstr, string("\t"));
    return s;
}

void initializeDataArray(JNIEnv *env, jobject obj,jobject haplotypes,jobject reads,vector<testcase>& tc_array,
                        jint numTestCases, vector<pair<jbyteArray,jbyte*> > & BasesArrayVector){
    //method in class ArrayList
    jclass list = env->GetObjectClass(reads);
    jmethodID arraylist_get = env->GetMethodID(list,"get","(I)Ljava/lang/Object;");
    assert(arraylist_get && "Could not get methodID for cls_arraylist_get");
    jmethodID arraylist_size = env->GetMethodID(list,"size","()I");
    assert(arraylist_size && "Could not get methodID for cls_arraylist_size");
/*    assert(env->CallIntMethod(reads,arraylist_size)==env->CallIntMethod(haplotypes,arraylist_size));
    assert(env->CallIntMethod(reads,arraylist_size)==numTestCases);*/
    jboolean is_copy = JNI_FALSE;
    for(int i=0;i<numTestCases;i++){
        jbyteArray ref = (jbyteArray)env->CallObjectMethod(haplotypes,arraylist_get,i);
        assert(ref && "Could not get methodID for ref");
        jbyteArray alt = (jbyteArray)env->CallObjectMethod(reads,arraylist_get,i);
        jsize refLen = env->GetArrayLength(ref);
        jsize altLen = env->GetArrayLength(alt);
        jbyte * refbase = env->GetByteArrayElements(ref,&is_copy);
        jbyte * altbase = env->GetByteArrayElements(alt,&is_copy);

        tc_array[i].refLen = (int)refLen;
        tc_array[i].altLen = (int)altLen;
        tc_array[i].reference = (char*)refbase;
        tc_array[i].alternate = (char*)altbase;

        BasesArrayVector[2*i] = make_pair(ref, refbase);
        BasesArrayVector[2*i+1] = make_pair(alt, altbase);

    }
}
inline void ReleaseReadArrays
  (JNIEnv* env, vector<pair<jbyteArray,jbyte*> > & BasesArrayVector)
{
  //Release read arrays first
  for(int i=BasesArrayVector.size()-1;i>=0;--i)//note the order - reverse of GET
  {
      env->ReleaseByteArrayElements(BasesArrayVector[i].first, BasesArrayVector[i].second, JNI_ABORT);
  }
//  BasesArrayVector.clear();
    vector<pair<jbyteArray,jbyte*> >().swap(BasesArrayVector);
}
/*
 * Class:     org_broadinstitute_gatk_utils_smithwaterman_BatchSWPairwiseAlignment
 * Method:    jniAlign
 * Signature: (Ljava/util/ArrayList;Ljava/util/ArrayList;Ljava/util/ArrayList;Ljava/util/ArrayList;)V
 */
JNIEXPORT jstring JNICALL Java_org_broadinstitute_gatk_utils_smithwaterman_BatchSWPairwiseAlignment_jniAlign
  (JNIEnv *env, jobject obj, jobject haplotypes, jobject reads,jint numTestCases, jint numThreads){
		vector<testcase> tc_array;
        tc_array.clear();
        tc_array.resize(numTestCases);
        vector<pair<jbyteArray,jbyte*> > BasesArrayVector;
        BasesArrayVector.clear();
        BasesArrayVector.resize(numTestCases*2);
        initializeDataArray(env,obj,haplotypes,reads, tc_array,numTestCases, BasesArrayVector);
        string s = compute_testcases(env,obj,tc_array, numTestCases,numThreads);
        ReleaseReadArrays(env,BasesArrayVector);
//        tc_array.clear();
        vector<testcase>().swap(tc_array);
        return env->NewStringUTF(s.c_str());
  }

