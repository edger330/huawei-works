 /* DO NOT EDIT THIS FILE - it is machine generated */
#include <vector>
#include <assert.h>
#include "utils.h"
#include "org_broadinstitute_gatk_utils_pairhmm_CPPPairHMM.h"
#include "LoadTimeInitializer.h"
#include "jni_common.h"

using namespace std;
/*
 * Class:     org_broadinstitute_gatk_utils_pairhmm_CPPPairHMM
 * Method:    initCPP
 * Signature: (Ljava/lang/Class;Ljava/lang/Class;)V
 */
JNIEXPORT void JNICALL Java_org_broadinstitute_gatk_utils_pairhmm_CPPPairHMM_initCPP
        (JNIEnv * env,  jobject obj,jclass readDataHolderClass, jclass haplotypeDataHolderClass){
  assert(readDataHolderClass);
  assert(haplotypeDataHolderClass);
  jfieldID fid;
  fid = env->GetFieldID(readDataHolderClass, "readBases", "[B");
  assert(fid && "JNI pairHMM: Could not get FID for readBases");
  g_load_time_initializer.m_readBasesFID = fid;
  fid = env->GetFieldID(readDataHolderClass, "readQuals", "[B");
  assert(fid && "JNI pairHMM: Could not get FID for readQuals");
  g_load_time_initializer.m_readQualsFID = fid;
  fid = env->GetFieldID(readDataHolderClass, "insertionGOP", "[B");
  assert(fid && "JNI pairHMM: Could not get FID for insertionGOP");
  g_load_time_initializer.m_insertionGOPFID = fid;
  fid = env->GetFieldID(readDataHolderClass, "deletionGOP", "[B");
  assert(fid && "JNI pairHMM: Could not get FID for deletionGOP");
  g_load_time_initializer.m_deletionGOPFID = fid;
  fid = env->GetFieldID(readDataHolderClass, "overallGCP", "[B");
  assert(fid && "JNI pairHMM: Could not get FID for overallGCP");
  g_load_time_initializer.m_overallGCPFID = fid;

  fid = env->GetFieldID(haplotypeDataHolderClass, "haplotypeBases", "[B");
  assert(fid && "JNI pairHMM: Could not get FID for haplotypeBases");
  g_load_time_initializer.m_haplotypeBasesFID = fid;
}


/*
 * Class:     org_broadinstitute_gatk_utils_pairhmm_CPPPairHMM
 * Method:    doneCPP
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_org_broadinstitute_gatk_utils_pairhmm_CPPPairHMM_doneCPP
  (JNIEnv * env, jobject obj){}


 inline void compute_testcases(vector<testcase>& tc_array, unsigned numTestCases, double* likelihoodDoubleArray,
                               unsigned maxNumThreadsToUse)
 {
//    int numThreads = omp_get_num_procs() * 0.8;
#pragma omp parallel for schedule (dynamic,100) num_threads(maxNumThreadsToUse)
     for(unsigned tc_idx=0;tc_idx<numTestCases;++tc_idx)
     {

         float result_avxf = g_compute_full_prob_float(&(tc_array[tc_idx]), 0);

/*	  printf("c:%x\n", *((unsigned int *)&result_avxf));
  exit(0);*/
         double result = 0;
         if (result_avxf < MIN_ACCEPTED) {
             double result_avxd = g_compute_full_prob_double(&(tc_array[tc_idx]), 0);
             result = log10(result_avxd) - log10(ldexp(1.0, 1020.0));
#ifdef DO_PROFILING
             g_load_time_initializer.update_stat(NUM_DOUBLE_INVOCATIONS_IDX, 1);
#endif
         }
         else
             result = (double)(log10f(result_avxf) - log10f(ldexpf(1.f, 120.f)));
//         std::cerr<<"value: "<<result<<endl;
         likelihoodDoubleArray[tc_idx] = result;
     }
 }
/*
 * Class:     org_broadinstitute_gatk_utils_pairhmm_CPPPairHMM
 * Method:    sendDataAndResiveFromCPP
 * Signature: (IIII[Lorg/broadinstitute/gatk/utils/pairhmm/CPPPairHMM/JNIReadDataHolderClass;[Lorg/broadinstitute/gatk/utils/pairhmm/CPPPairHMM/JNIHaplotypeDataHolderClass;)[F
 */
JNIEXPORT void JNICALL Java_org_broadinstitute_gatk_utils_pairhmm_CPPPairHMM_sendDataAndResiveFromCPP
   (JNIEnv * env, jobject obj, jint taskID, jint sampleID, jint numReads, jint numHaplotypes,
         jobjectArray readDataArray, jobjectArray haplotypeDataArray,jdoubleArray likelihoodArray, jint numThreads){
    int numTestCases = numReads * numHaplotypes;
    vector<testcase> tc_array;
    tc_array.clear();
    tc_array.resize(numTestCases);
    jboolean is_copy = JNI_FALSE;

    jdouble* likelihoodDoubleArray = (jdouble*)GET_DOUBLE_ARRAY_ELEMENTS(likelihoodArray, &is_copy);

    vector<pair<jbyteArray, jbyte*> > haplotypeBasesArrayVector;
    vector<unsigned> hapLengths;
    haplotypeBasesArrayVector.resize(numHaplotypes);
    hapLengths.resize(numHaplotypes);
    for(int j=0;j<numHaplotypes;j++){
        jobject hapObject = env->GetObjectArrayElement(haplotypeDataArray, j);
        jbyteArray hapBases = (jbyteArray)env->GetObjectField(hapObject, g_load_time_initializer.m_haplotypeBasesFID);
        jsize hapLength = env->GetArrayLength(hapBases);
        jbyte* hapBasesArray = (jbyte*)env->GetByteArrayElements(hapBases, &is_copy);	//order of GET-RELEASE is important
        haplotypeBasesArrayVector[j] = make_pair(hapBases, hapBasesArray);
        hapLengths[j] = hapLength;
    }

    vector<vector<pair<jbyteArray,jbyte*> > > readBasesArrayVector;
    readBasesArrayVector.clear();
    readBasesArrayVector.resize(numReads);
    unsigned tc_idx = 0;
    for(unsigned i=0;i<numReads;i++){
        jobject readObject = env->GetObjectArrayElement(readDataArray, i);
        jbyteArray readBases = (jbyteArray)env->GetObjectField(readObject, g_load_time_initializer.m_readBasesFID);
        jbyteArray insertionGOP = (jbyteArray)env->GetObjectField(readObject, g_load_time_initializer.m_insertionGOPFID);
        jbyteArray deletionGOP = (jbyteArray)env->GetObjectField(readObject, g_load_time_initializer.m_deletionGOPFID);
        jbyteArray overallGCP = (jbyteArray)env->GetObjectField(readObject, g_load_time_initializer.m_overallGCPFID);
        jbyteArray readQuals = (jbyteArray)env->GetObjectField(readObject, g_load_time_initializer.m_readQualsFID);
        jbyte* readBasesArray = (jbyte*)env->GetByteArrayElements(readBases, &is_copy);	//order of GET-RELEASE is important
        jsize readLength = env->GetArrayLength(readBases);

        jbyte* readQualsArray = (jbyte*)env->GetByteArrayElements(readQuals, &is_copy);
        jbyte* insertionGOPArray = (jbyte*)env->GetByteArrayElements(insertionGOP, &is_copy);
        jbyte* deletionGOPArray = (jbyte*)env->GetByteArrayElements(deletionGOP, &is_copy);
        jbyte* overallGCPArray = (jbyte*)env->GetByteArrayElements(overallGCP, &is_copy);
        for(unsigned j=0;j<numHaplotypes;j++){
            jsize haplotypeLength = (jsize)hapLengths[j];
            jbyte* haplotypeBasesArray = haplotypeBasesArrayVector[j].second;
            tc_array[tc_idx].rslen = (int)readLength;
            tc_array[tc_idx].haplen = (int)hapLengths[j];
            tc_array[tc_idx].hap = (char*)haplotypeBasesArray;
            tc_array[tc_idx].rs = (char*)readBasesArray;
            tc_array[tc_idx].q = (char*)readQualsArray;
            tc_array[tc_idx].i = (char*)insertionGOPArray;
            tc_array[tc_idx].d = (char*)deletionGOPArray;
            tc_array[tc_idx].c = (char*)overallGCPArray;

            ++tc_idx;
        }
        readBasesArrayVector[i].clear();
        readBasesArrayVector[i].resize(5);
        readBasesArrayVector[i][0] = make_pair(readBases, readBasesArray);
        readBasesArrayVector[i][1] = make_pair(readQuals, readQualsArray);
        readBasesArrayVector[i][2] = make_pair(insertionGOP, insertionGOPArray);
        readBasesArrayVector[i][3] = make_pair(deletionGOP, deletionGOPArray);
        readBasesArrayVector[i][4] = make_pair(overallGCP, overallGCPArray);

    }
    compute_testcases(tc_array,numTestCases,likelihoodDoubleArray,numThreads);
/*    for(int i=0;i<numTestCases;i++){
        std::cerr<<"value: "<<likelihoodDoubleArray[i]<<endl;
    }*/

    tc_array.clear();

    RELEASE_DOUBLE_ARRAY_ELEMENTS(likelihoodArray, likelihoodDoubleArray, 0); //release mode 0, copy back results to Java


    for(int i=readBasesArrayVector.size()-1;i>=0;--i)//note the order - reverse of GET
    {
        for(int j=readBasesArrayVector[i].size()-1;j>=0;--j)
            RELEASE_BYTE_ARRAY_ELEMENTS(readBasesArrayVector[i][j].first, readBasesArrayVector[i][j].second, JNI_RO_RELEASE_MODE);
        readBasesArrayVector[i].clear();
    }

    for(int j=haplotypeBasesArrayVector.size()-1;j>=0;--j)	//note the order - reverse of GET
    {
        RELEASE_BYTE_ARRAY_ELEMENTS(haplotypeBasesArrayVector[j].first, haplotypeBasesArrayVector[j].second, JNI_RO_RELEASE_MODE);
    }

    haplotypeBasesArrayVector.clear();
    readBasesArrayVector.clear();
    hapLengths.clear();

    // todo, release JNI memory
}


