/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <climits>
#include <cmath>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <sstream>

using namespace std;
/* Header for class org_broadinstitute_gatk_utils_smithwaterman_SWPairwiseAlignment */

#include "org_broadinstitute_gatk_utils_smithwaterman_SWPairwiseAlignment.h"
/*
 * Class:     org_broadinstitute_gatk_utils_smithwaterman_SWPairwiseAlignment
 * Method:    calculateMatrix
 * Signature: ([B[B[[I[[ILorg/broadinstitute/gatk/utils/smithwaterman/SWPairwiseAlignment/OVERHANG_STRATEGY;Lorg/broadinstitute/gatk/utils/smithwaterman/Parameters;)V
 */
typedef struct {
	int w_open;
	int w_extend;
	int w_match;
	int w_mismatch;
}Parameter;

enum State{
        MATCH,
        INSERTION,
        DELETION,
        CLIP
};
inline string int_to_string(int a){
    stringstream ss;
    ss<<a;
    string str = ss.str();
    return str;
}

inline const char* ToString(State v)
{
    switch (v)
    {
        case MATCH:   return "MATCH";
        case INSERTION:   return "INSERTION";
        case DELETION: return "DELETION";
        case CLIP:      return "CLIP";
        default: return "NONE";
    }
}
bool cutOff = false;

inline void compute_matrix( JNIEnv *env, jobject obj, jbyteArray reference, jbyteArray alternate,
                            int** sw, int ** btrack, int nrow, int ncol,Parameter & para, const char* strategyName){
	int MATRIX_MIN_CUTOFF;   // never let matrix elements drop below this cutoff
    if ( cutOff ) MATRIX_MIN_CUTOFF = 0;
    else MATRIX_MIN_CUTOFF = (int) -1e8;
    int minIntValue = INT_MIN>>1;

    int* best_gap_v = new int[ncol+1];
    std::fill_n(best_gap_v,ncol+1,minIntValue);
    int* gap_size_v = new int[ncol+1];
    int* best_gap_h = new int[nrow+1];
    std::fill_n(best_gap_h,nrow+1,minIntValue);
    int* gap_size_h = new int[nrow+1];

    if(strcmp(strategyName, "INDEL")==0 || strcmp(strategyName, "LEADING_INDEL")==0){
        // initialize the first row
        sw[0][0]=0;
        int* topRow=sw[0];
        topRow[1]=para.w_open;
        int currentValue = para.w_open;
        for ( int i = 2; i < ncol; i++ ) {
            currentValue += para.w_extend;
            topRow[i]=currentValue;
        }
        // initialize the first column
        sw[1][0]=para.w_open;
        currentValue = para.w_open;
        for ( int i = 2; i < nrow; i++ ) {
            currentValue += para.w_extend;
            sw[i][0]=currentValue;
        }
    }
    int* curRow=sw[0];
    jboolean is_copy=JNI_FALSE;
/*    unsigned char * ref = new unsigned char[nrow-1];
    unsigned char * alt = new unsigned char[ncol-1];
    env->GetByteArrayRegion (reference, 0, nrow-1, reinterpret_cast<jbyte*>(ref));
    env->GetByteArrayRegion (alternate, 0, ncol-1, reinterpret_cast<jbyte*>(alt));*/
    jbyte* ref = env->GetByteArrayElements(reference, &is_copy);
    jbyte* alt = env->GetByteArrayElements(alternate, &is_copy);
    for ( int i = 1; i <nrow ; i++ ) {
        char a_base = ref[i-1]; // letter in a at the current pos
        int* lastRow=curRow;
        curRow=sw[i];
        int* curBackTrackRow=btrack[i];
        for ( int j = 1; j < ncol; j++) {
            char b_base = alt[j-1]; // letter in b at the current pos
            // in other words, step_diag = sw[i-1][j-1] + wd(a_base,b_base);
            int step_diag = lastRow[j-1] + (a_base == b_base ? para.w_match : para.w_mismatch);

            // optimized "traversal" of all the matrix cells above the current one (i.e. traversing
            // all 'step down' events that would end in the current cell. The optimized code
            // does exactly the same thing as the commented out loop below. IMPORTANT:
            // the optimization works ONLY for linear w(k)=wopen+(k-1)*wextend!!!!

            // if a gap (length 1) was just opened above, this is the cost of arriving to the current cell:
            int prev_gap = lastRow[j]+para.w_open;
            best_gap_v[j] += para.w_extend; // for the gaps that were already opened earlier, extending them by 1 costs w_extend
             if (  prev_gap > best_gap_v[j]  ) {
                // opening a gap just before the current cell results in better score than extending by one
                // the best previously opened gap. This will hold for ALL cells below: since any gap
                // once opened always costs w_extend to extend by another base, we will always get a better score
                // by arriving to any cell below from the gap we just opened (prev_gap) rather than from the previous best gap
                best_gap_v[j] = prev_gap;
                gap_size_v[j] = 1; // remember that the best step-down gap from above has length 1 (we just opened it)
            } else {
                // previous best gap is still the best, even after extension by another base, so we just record that extension:
                gap_size_v[j]++;
            }
            int step_down = best_gap_v[j] ;
            int kd = gap_size_v[j];
            // optimized "traversal" of all the matrix cells to the left of the current one (i.e. traversing
            // all 'step right' events that would end in the current cell. The optimized code
            // does exactly the same thing as the commented out loop below. IMPORTANT:
            // the optimization works ONLY for linear w(k)=wopen+(k-1)*wextend!!!!

            prev_gap =curRow[j-1]  + para.w_open; // what would it cost us to open length 1 gap just to the left from current cell
            best_gap_h[i] += para.w_extend; // previous best gap would cost us that much if extended by another base
            if ( prev_gap > best_gap_h[i] ) {
                // newly opened gap is better (score-wise) than any previous gap with the same row index i; since
                // gap penalty is linear with k, this new gap location is going to remain better than any previous ones
                best_gap_h[i] = prev_gap;
                gap_size_h[i] = 1;
            } else {
                gap_size_h[i]++;
            }
            int step_right = best_gap_h[i];
            int ki = gap_size_h[i];

            //priority here will be step diagonal, step right, step down
            bool diagHighestOrEqual = (step_diag >= step_down)
                                            && (step_diag >= step_right);

            if ( diagHighestOrEqual ) {
                curRow[j]=max(MATRIX_MIN_CUTOFF,step_diag);
                curBackTrackRow[j]=0;
            }
            else if(step_right>=step_down) { //moving right is the highest
                curRow[j]=max(MATRIX_MIN_CUTOFF,step_right);
                curBackTrackRow[j]=-ki; // negative = horizontal
            }
            else  {
                curRow[j]=max(MATRIX_MIN_CUTOFF,step_down);
                curBackTrackRow[j]= kd; // positive=vertical
            }
        }
    }
    env->ReleaseByteArrayElements(reference,ref,0);
    env->ReleaseByteArrayElements(alternate,alt,0);
/*
    delete[] ref;
    delete[] alt;*/
    delete[] best_gap_v;
    delete[] gap_size_v;
    delete[] best_gap_h;
    delete[] gap_size_h;

}

inline int compute_cigar(JNIEnv *env, jobject obj, int refLen , int altLen,int ** sw, int ** btrack, Parameter & para, const char* strategyName,
					jobject cigars_op, jobject cigars_len){

	int alignment_offset ;
    jclass cls_op = env->GetObjectClass(cigars_op);
    jclass cls_len = env->GetObjectClass(cigars_len);
    jmethodID op_add = env->GetMethodID(cls_op,"add","(Ljava/lang/Object;)Z");
    jmethodID len_add = env->GetMethodID(cls_len,"add","(Ljava/lang/Object;)Z");

	int p1=0, p2=0;
	int maxscore = INT_MIN;
	int segment_length=0;
	if(strcmp(strategyName, "INDEL")==0){
		p1 = refLen;
		p2 = altLen;
	}
	else{
		p2 = altLen;
		for(int i=1;i<refLen+1; i++){
			int curScore = sw[i][altLen];
			if(curScore >= maxscore){
				p1 = i;
				maxscore = curScore;
			}
		}
		if(strcmp(strategyName, "LEADING_INDEL")!=0){
			int * bottomRow = sw[refLen];
			for(int j=1; j<altLen+1; j++){
                int curScore=bottomRow[j];
                // data_offset is the offset of [n][j]
                if ( curScore > maxscore ||
                        (curScore == maxscore && abs(refLen-j) < abs(p1 - p2) ) ) {
                    p1 = refLen;
                    p2 = j ;
                    maxscore = curScore;
                    segment_length = altLen - j ; // end of sequence 2 is overhanging; we will just record it as 'M' segment
                }

			}

		}
	}
    if ( segment_length > 0 && strcmp(strategyName,"SOFTCLIP")==0 ) {
        jstring op = env->NewStringUTF("CLIP");
        jstring len = env->NewStringUTF(int_to_string(segment_length).c_str());
        env->CallObjectMethod(cigars_op,op_add,op);
        env->CallObjectMethod(cigars_len,len_add,len);
        segment_length = 0;
    }
    State state = MATCH;
    do{
        int btr = btrack[p1][p2];
        State new_state;
        int step_length = 1;
        if(btr >0 ){
            new_state = DELETION;
            step_length = btr;
        }
        else if( btr<0){
            new_state = INSERTION;
            step_length = -btr;
        }
        else{
            new_state = MATCH;
        }
        switch(new_state){
            case MATCH:
            {
                p1--;
                p2--;
            }
                break;
            case INSERTION:
                p2 -= step_length;
                break;
            case DELETION:
                p1 -= step_length;
                break;
        }

        if(new_state==state) segment_length += step_length;
        else{
            jstring op = env->NewStringUTF(ToString(state));
            jstring len = env->NewStringUTF(int_to_string(segment_length).c_str());
            env->CallObjectMethod(cigars_op,op_add,op);
            env->CallObjectMethod(cigars_len,len_add,len);
            segment_length = step_length;
            state = new_state;
        }
    }while(p1>0 && p2>0);

    if ( strcmp(strategyName,"SOFTCLIP")==0 ) {
        jstring op = env->NewStringUTF(ToString(state));
        jstring len = env->NewStringUTF(int_to_string(segment_length).c_str());
        env->CallObjectMethod(cigars_op,op_add,op);
        env->CallObjectMethod(cigars_len,len_add,len);
        if ( p2 > 0 ){
            jstring op = env->NewStringUTF("CLIP");
            jstring len = env->NewStringUTF(int_to_string(p2).c_str());
            env->CallObjectMethod(cigars_op,op_add,op);
            env->CallObjectMethod(cigars_len,len_add,len);
        }
        alignment_offset = p1;
    } else if ( strcmp(strategyName,"IGNORE")==0 ) {
        jstring op = env->NewStringUTF(ToString(state));
        jstring len = env->NewStringUTF(int_to_string(segment_length+p2).c_str());
        env->CallObjectMethod(cigars_op,op_add,op);
        env->CallObjectMethod(cigars_len,len_add,len);
        alignment_offset = p1 - p2;
    } else {  // overhang_strategy == OVERHANG_STRATEGY.INDEL || overhang_strategy == OVERHANG_STRATEGY.LEADING_INDEL

        // take care of the actual alignment
        jstring op = env->NewStringUTF(ToString(state));
        jstring len = env->NewStringUTF(int_to_string(segment_length).c_str());
        env->CallObjectMethod(cigars_op,op_add,op);
        env->CallObjectMethod(cigars_len,len_add,len);

        // take care of overhangs at the beginning of the alignment
        if ( p1 > 0 ){
            jstring op = env->NewStringUTF("DELETION");
            jstring len = env->NewStringUTF(int_to_string(p1).c_str());
            env->CallObjectMethod(cigars_op,op_add, op);
            env->CallObjectMethod(cigars_len,len_add,len);
        }
        else if ( p2 > 0 ){
            jstring op = env->NewStringUTF("INSERTION");
            jstring len = env->NewStringUTF(int_to_string(p2).c_str());
            env->CallObjectMethod(cigars_op,op_add,op);
            env->CallObjectMethod(cigars_len,len_add,len);
        }

        alignment_offset = 0;
    }
    return alignment_offset;
}

JNIEXPORT jint  JNICALL Java_org_broadinstitute_gatk_utils_smithwaterman_SWPairwiseAlignment_calculateMatrix
  	(JNIEnv * env, jobject obj, jbyteArray reference, jbyteArray alternate,
  	jint w_match, jint w_mismatch, jint w_open, jint w_extend, jstring strategyName,
     jobject cigars_op, jobject cigars_len)
 {

    Parameter para;
    para.w_match=w_match;
    para.w_mismatch=w_mismatch;
    para.w_open=w_open;
    para.w_extend=w_extend;
    const char *strategy = env->GetStringUTFChars(strategyName, 0);
// calculate
    int refLen = env->GetArrayLength(reference);
    int altLen = env->GetArrayLength(alternate);
    if(refLen==0 || altLen==0){
        cerr<<"NULL reference or alternate";
        exit(1);
    }
    int nrow = refLen+1;
    int ncol = altLen+1;
    int** sw = new int*[nrow];
    int** btrack = new int*[nrow];
    for(int i = 0; i < nrow; ++i){
        sw[i] = new int[ncol];
        btrack[i] = new int[ncol];
        std::fill_n(btrack[i],ncol,0);
        std::fill_n(sw[i],ncol,0);
    }
	compute_matrix(env, obj, reference, alternate, sw,btrack, nrow, ncol, para, strategy);
    int alignment_offset = compute_cigar(env, obj, refLen, altLen, sw, btrack, para, strategy, cigars_op, cigars_len);
    for(int i = 0; i < nrow; ++i) {
        delete [] sw[i];
        delete [] btrack[i];
    }
    delete[] sw;
    delete[] btrack;
    return alignment_offset;
}
